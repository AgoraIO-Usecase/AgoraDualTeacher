/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "cache_items_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace agora { namespace cache {


DnsItem::~DnsItem() throw() {
}


void DnsItem::__set_expired(const int64_t val) {
  this->expired = val;
}

void DnsItem::__set_ipList(const std::vector<int32_t> & val) {
  this->ipList = val;
}

const char* DnsItem::ascii_fingerprint = "5DDE96F44B125BEA7379750973DE133C";
const uint8_t DnsItem::binary_fingerprint[16] = {0x5D,0xDE,0x96,0xF4,0x4B,0x12,0x5B,0xEA,0x73,0x79,0x75,0x09,0x73,0xDE,0x13,0x3C};

uint32_t DnsItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expired);
          this->__isset.expired = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ipList.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->ipList.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readI32(this->ipList[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ipList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DnsItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DnsItem");

  xfer += oprot->writeFieldBegin("expired", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->expired);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ipList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->ipList.size()));
    std::vector<int32_t> ::const_iterator _iter5;
    for (_iter5 = this->ipList.begin(); _iter5 != this->ipList.end(); ++_iter5)
    {
      xfer += oprot->writeI32((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DnsItem &a, DnsItem &b) {
  using ::std::swap;
  swap(a.expired, b.expired);
  swap(a.ipList, b.ipList);
  swap(a.__isset, b.__isset);
}

DnsItem::DnsItem(const DnsItem& other6) {
  expired = other6.expired;
  ipList = other6.ipList;
  __isset = other6.__isset;
}
DnsItem& DnsItem::operator=(const DnsItem& other7) {
  expired = other7.expired;
  ipList = other7.ipList;
  __isset = other7.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DnsItem& obj) {
  using apache::thrift::to_string;
  out << "DnsItem(";
  out << "expired=" << to_string(obj.expired);
  out << ", " << "ipList=" << to_string(obj.ipList);
  out << ")";
  return out;
}


DnsItem2::~DnsItem2() throw() {
}


void DnsItem2::__set_expired(const int64_t val) {
  this->expired = val;
}

void DnsItem2::__set_ipList(const std::vector<std::string> & val) {
  this->ipList = val;
}

const char* DnsItem2::ascii_fingerprint = "99F1C039E3B3A6BDFA4977B74CE92EB8";
const uint8_t DnsItem2::binary_fingerprint[16] = {0x99,0xF1,0xC0,0x39,0xE3,0xB3,0xA6,0xBD,0xFA,0x49,0x77,0xB7,0x4C,0xE9,0x2E,0xB8};

uint32_t DnsItem2::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expired);
          this->__isset.expired = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ipList.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readListBegin(_etype11, _size8);
            this->ipList.resize(_size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              xfer += iprot->readString(this->ipList[_i12]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ipList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DnsItem2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("DnsItem2");

  xfer += oprot->writeFieldBegin("expired", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->expired);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ipList", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->ipList.size()));
    std::vector<std::string> ::const_iterator _iter13;
    for (_iter13 = this->ipList.begin(); _iter13 != this->ipList.end(); ++_iter13)
    {
      xfer += oprot->writeString((*_iter13));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(DnsItem2 &a, DnsItem2 &b) {
  using ::std::swap;
  swap(a.expired, b.expired);
  swap(a.ipList, b.ipList);
  swap(a.__isset, b.__isset);
}

DnsItem2::DnsItem2(const DnsItem2& other14) {
  expired = other14.expired;
  ipList = other14.ipList;
  __isset = other14.__isset;
}
DnsItem2& DnsItem2::operator=(const DnsItem2& other15) {
  expired = other15.expired;
  ipList = other15.ipList;
  __isset = other15.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const DnsItem2& obj) {
  using apache::thrift::to_string;
  out << "DnsItem2(";
  out << "expired=" << to_string(obj.expired);
  out << ", " << "ipList=" << to_string(obj.ipList);
  out << ")";
  return out;
}


Policy::~Policy() throw() {
}


void Policy::__set_expired(const int64_t val) {
  this->expired = val;
}

void Policy::__set_params(const std::string& val) {
  this->params = val;
__isset.params = true;
}

const char* Policy::ascii_fingerprint = "B1A3984BF7F74C1706A525A526B7E1B2";
const uint8_t Policy::binary_fingerprint[16] = {0xB1,0xA3,0x98,0x4B,0xF7,0xF7,0x4C,0x17,0x06,0xA5,0x25,0xA5,0x26,0xB7,0xE1,0xB2};

uint32_t Policy::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->expired);
          this->__isset.expired = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->params);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Policy::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Policy");

  xfer += oprot->writeFieldBegin("expired", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->expired);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.params) {
    xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->params);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Policy &a, Policy &b) {
  using ::std::swap;
  swap(a.expired, b.expired);
  swap(a.params, b.params);
  swap(a.__isset, b.__isset);
}

Policy::Policy(const Policy& other16) {
  expired = other16.expired;
  params = other16.params;
  __isset = other16.__isset;
}
Policy& Policy::operator=(const Policy& other17) {
  expired = other17.expired;
  params = other17.params;
  __isset = other17.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Policy& obj) {
  using apache::thrift::to_string;
  out << "Policy(";
  out << "expired=" << to_string(obj.expired);
  out << ", " << "params="; (obj.__isset.params ? (out << to_string(obj.params)) : (out << "<null>"));
  out << ")";
  return out;
}


CacheDocument::~CacheDocument() throw() {
}


void CacheDocument::__set_dnsList(const std::map<std::string, std::map<std::string, DnsItem> > & val) {
  this->dnsList = val;
__isset.dnsList = true;
}

void CacheDocument::__set_lastSid(const std::string& val) {
  this->lastSid = val;
__isset.lastSid = true;
}

void CacheDocument::__set_failedSid(const std::string& val) {
  this->failedSid = val;
__isset.failedSid = true;
}

void CacheDocument::__set_policy(const Policy& val) {
  this->policy = val;
__isset.policy = true;
}

void CacheDocument::__set_dnsList2(const std::map<std::string, std::map<std::string, DnsItem2> > & val) {
  this->dnsList2 = val;
__isset.dnsList2 = true;
}

void CacheDocument::__set_installId(const std::string& val) {
  this->installId = val;
__isset.installId = true;
}

void CacheDocument::__set_netEngine(const int32_t val) {
  this->netEngine = val;
__isset.netEngine = true;
}

void CacheDocument::__set_agoraUniqueId(const std::string& val) {
  this->agoraUniqueId = val;
__isset.agoraUniqueId = true;
}

const char* CacheDocument::ascii_fingerprint = "B94E8EB82640EF5602F0A2815B3544F2";
const uint8_t CacheDocument::binary_fingerprint[16] = {0xB9,0x4E,0x8E,0xB8,0x26,0x40,0xEF,0x56,0x02,0xF0,0xA2,0x81,0x5B,0x35,0x44,0xF2};

uint32_t CacheDocument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dnsList.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              std::string _key23;
              xfer += iprot->readString(_key23);
              std::map<std::string, DnsItem> & _val24 = this->dnsList[_key23];
              {
                _val24.clear();
                uint32_t _size25;
                ::apache::thrift::protocol::TType _ktype26;
                ::apache::thrift::protocol::TType _vtype27;
                xfer += iprot->readMapBegin(_ktype26, _vtype27, _size25);
                uint32_t _i29;
                for (_i29 = 0; _i29 < _size25; ++_i29)
                {
                  std::string _key30;
                  xfer += iprot->readString(_key30);
                  DnsItem& _val31 = _val24[_key30];
                  xfer += _val31.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dnsList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lastSid);
          this->__isset.lastSid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->failedSid);
          this->__isset.failedSid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->policy.read(iprot);
          this->__isset.policy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dnsList2.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _ktype33;
            ::apache::thrift::protocol::TType _vtype34;
            xfer += iprot->readMapBegin(_ktype33, _vtype34, _size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              std::string _key37;
              xfer += iprot->readString(_key37);
              std::map<std::string, DnsItem2> & _val38 = this->dnsList2[_key37];
              {
                _val38.clear();
                uint32_t _size39;
                ::apache::thrift::protocol::TType _ktype40;
                ::apache::thrift::protocol::TType _vtype41;
                xfer += iprot->readMapBegin(_ktype40, _vtype41, _size39);
                uint32_t _i43;
                for (_i43 = 0; _i43 < _size39; ++_i43)
                {
                  std::string _key44;
                  xfer += iprot->readString(_key44);
                  DnsItem2& _val45 = _val38[_key44];
                  xfer += _val45.read(iprot);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dnsList2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->installId);
          this->__isset.installId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->netEngine);
          this->__isset.netEngine = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->agoraUniqueId);
          this->__isset.agoraUniqueId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CacheDocument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("CacheDocument");

  if (this->__isset.dnsList) {
    xfer += oprot->writeFieldBegin("dnsList", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->dnsList.size()));
      std::map<std::string, std::map<std::string, DnsItem> > ::const_iterator _iter46;
      for (_iter46 = this->dnsList.begin(); _iter46 != this->dnsList.end(); ++_iter46)
      {
        xfer += oprot->writeString(_iter46->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter46->second.size()));
          std::map<std::string, DnsItem> ::const_iterator _iter47;
          for (_iter47 = _iter46->second.begin(); _iter47 != _iter46->second.end(); ++_iter47)
          {
            xfer += oprot->writeString(_iter47->first);
            xfer += _iter47->second.write(oprot);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lastSid) {
    xfer += oprot->writeFieldBegin("lastSid", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->lastSid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.failedSid) {
    xfer += oprot->writeFieldBegin("failedSid", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->failedSid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.policy) {
    xfer += oprot->writeFieldBegin("policy", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->policy.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dnsList2) {
    xfer += oprot->writeFieldBegin("dnsList2", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->dnsList2.size()));
      std::map<std::string, std::map<std::string, DnsItem2> > ::const_iterator _iter48;
      for (_iter48 = this->dnsList2.begin(); _iter48 != this->dnsList2.end(); ++_iter48)
      {
        xfer += oprot->writeString(_iter48->first);
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter48->second.size()));
          std::map<std::string, DnsItem2> ::const_iterator _iter49;
          for (_iter49 = _iter48->second.begin(); _iter49 != _iter48->second.end(); ++_iter49)
          {
            xfer += oprot->writeString(_iter49->first);
            xfer += _iter49->second.write(oprot);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.installId) {
    xfer += oprot->writeFieldBegin("installId", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->installId);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.netEngine) {
    xfer += oprot->writeFieldBegin("netEngine", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->netEngine);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.agoraUniqueId) {
    xfer += oprot->writeFieldBegin("agoraUniqueId", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->agoraUniqueId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(CacheDocument &a, CacheDocument &b) {
  using ::std::swap;
  swap(a.dnsList, b.dnsList);
  swap(a.lastSid, b.lastSid);
  swap(a.failedSid, b.failedSid);
  swap(a.policy, b.policy);
  swap(a.dnsList2, b.dnsList2);
  swap(a.installId, b.installId);
  swap(a.netEngine, b.netEngine);
  swap(a.agoraUniqueId, b.agoraUniqueId);
  swap(a.__isset, b.__isset);
}

CacheDocument::CacheDocument(const CacheDocument& other50) {
  dnsList = other50.dnsList;
  lastSid = other50.lastSid;
  failedSid = other50.failedSid;
  policy = other50.policy;
  dnsList2 = other50.dnsList2;
  installId = other50.installId;
  netEngine = other50.netEngine;
  agoraUniqueId = other50.agoraUniqueId;
  __isset = other50.__isset;
}
CacheDocument& CacheDocument::operator=(const CacheDocument& other51) {
  dnsList = other51.dnsList;
  lastSid = other51.lastSid;
  failedSid = other51.failedSid;
  policy = other51.policy;
  dnsList2 = other51.dnsList2;
  installId = other51.installId;
  netEngine = other51.netEngine;
  agoraUniqueId = other51.agoraUniqueId;
  __isset = other51.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const CacheDocument& obj) {
  using apache::thrift::to_string;
  out << "CacheDocument(";
  out << "dnsList="; (obj.__isset.dnsList ? (out << to_string(obj.dnsList)) : (out << "<null>"));
  out << ", " << "lastSid="; (obj.__isset.lastSid ? (out << to_string(obj.lastSid)) : (out << "<null>"));
  out << ", " << "failedSid="; (obj.__isset.failedSid ? (out << to_string(obj.failedSid)) : (out << "<null>"));
  out << ", " << "policy="; (obj.__isset.policy ? (out << to_string(obj.policy)) : (out << "<null>"));
  out << ", " << "dnsList2="; (obj.__isset.dnsList2 ? (out << to_string(obj.dnsList2)) : (out << "<null>"));
  out << ", " << "installId="; (obj.__isset.installId ? (out << to_string(obj.installId)) : (out << "<null>"));
  out << ", " << "netEngine="; (obj.__isset.netEngine ? (out << to_string(obj.netEngine)) : (out << "<null>"));
  out << ", " << "agoraUniqueId="; (obj.__isset.agoraUniqueId ? (out << to_string(obj.agoraUniqueId)) : (out << "<null>"));
  out << ")";
  return out;
}


PolicyDocument::~PolicyDocument() throw() {
}


void PolicyDocument::__set_version(const int32_t val) {
  this->version = val;
}

void PolicyDocument::__set_params(const std::string& val) {
  this->params = val;
__isset.params = true;
}

const char* PolicyDocument::ascii_fingerprint = "96705E9A3FD7B072319C71653E0DBB90";
const uint8_t PolicyDocument::binary_fingerprint[16] = {0x96,0x70,0x5E,0x9A,0x3F,0xD7,0xB0,0x72,0x31,0x9C,0x71,0x65,0x3E,0x0D,0xBB,0x90};

uint32_t PolicyDocument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->params);
          this->__isset.params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PolicyDocument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("PolicyDocument");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.params) {
    xfer += oprot->writeFieldBegin("params", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->params);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(PolicyDocument &a, PolicyDocument &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.params, b.params);
  swap(a.__isset, b.__isset);
}

PolicyDocument::PolicyDocument(const PolicyDocument& other52) {
  version = other52.version;
  params = other52.params;
  __isset = other52.__isset;
}
PolicyDocument& PolicyDocument::operator=(const PolicyDocument& other53) {
  version = other53.version;
  params = other53.params;
  __isset = other53.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const PolicyDocument& obj) {
  using apache::thrift::to_string;
  out << "PolicyDocument(";
  out << "version=" << to_string(obj.version);
  out << ", " << "params="; (obj.__isset.params ? (out << to_string(obj.params)) : (out << "<null>"));
  out << ")";
  return out;
}


ReportCacheItem::~ReportCacheItem() throw() {
}


void ReportCacheItem::__set_sent_ts(const int64_t val) {
  this->sent_ts = val;
}

void ReportCacheItem::__set_payload(const std::string& val) {
  this->payload = val;
}

void ReportCacheItem::__set_level(const int32_t val) {
  this->level = val;
}

void ReportCacheItem::__set_vid(const int32_t val) {
  this->vid = val;
__isset.vid = true;
}

void ReportCacheItem::__set_cid(const int32_t val) {
  this->cid = val;
__isset.cid = true;
}

void ReportCacheItem::__set_type(const int32_t val) {
  this->type = val;
}

const char* ReportCacheItem::ascii_fingerprint = "445B302D64924CFE165AEE8082F44C03";
const uint8_t ReportCacheItem::binary_fingerprint[16] = {0x44,0x5B,0x30,0x2D,0x64,0x92,0x4C,0xFE,0x16,0x5A,0xEE,0x80,0x82,0xF4,0x4C,0x03};

uint32_t ReportCacheItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sent_ts);
          this->__isset.sent_ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->payload);
          this->__isset.payload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->level);
          this->__isset.level = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->vid);
          this->__isset.vid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReportCacheItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ReportCacheItem");

  xfer += oprot->writeFieldBegin("sent_ts", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sent_ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("payload", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->payload);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("level", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->level);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.vid) {
    xfer += oprot->writeFieldBegin("vid", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->vid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ReportCacheItem &a, ReportCacheItem &b) {
  using ::std::swap;
  swap(a.sent_ts, b.sent_ts);
  swap(a.payload, b.payload);
  swap(a.level, b.level);
  swap(a.vid, b.vid);
  swap(a.cid, b.cid);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

ReportCacheItem::ReportCacheItem(const ReportCacheItem& other54) {
  sent_ts = other54.sent_ts;
  payload = other54.payload;
  level = other54.level;
  vid = other54.vid;
  cid = other54.cid;
  type = other54.type;
  __isset = other54.__isset;
}
ReportCacheItem& ReportCacheItem::operator=(const ReportCacheItem& other55) {
  sent_ts = other55.sent_ts;
  payload = other55.payload;
  level = other55.level;
  vid = other55.vid;
  cid = other55.cid;
  type = other55.type;
  __isset = other55.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ReportCacheItem& obj) {
  using apache::thrift::to_string;
  out << "ReportCacheItem(";
  out << "sent_ts=" << to_string(obj.sent_ts);
  out << ", " << "payload=" << to_string(obj.payload);
  out << ", " << "level=" << to_string(obj.level);
  out << ", " << "vid="; (obj.__isset.vid ? (out << to_string(obj.vid)) : (out << "<null>"));
  out << ", " << "cid="; (obj.__isset.cid ? (out << to_string(obj.cid)) : (out << "<null>"));
  out << ", " << "type=" << to_string(obj.type);
  out << ")";
  return out;
}


ReportCacheDocument::~ReportCacheDocument() throw() {
}


void ReportCacheDocument::__set_reportCacheList(const std::map<int64_t, ReportCacheItem> & val) {
  this->reportCacheList = val;
__isset.reportCacheList = true;
}

const char* ReportCacheDocument::ascii_fingerprint = "92FC1E5189E49B1A871531354B1011C8";
const uint8_t ReportCacheDocument::binary_fingerprint[16] = {0x92,0xFC,0x1E,0x51,0x89,0xE4,0x9B,0x1A,0x87,0x15,0x31,0x35,0x4B,0x10,0x11,0xC8};

uint32_t ReportCacheDocument::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->reportCacheList.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _ktype57;
            ::apache::thrift::protocol::TType _vtype58;
            xfer += iprot->readMapBegin(_ktype57, _vtype58, _size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              int64_t _key61;
              xfer += iprot->readI64(_key61);
              ReportCacheItem& _val62 = this->reportCacheList[_key61];
              xfer += _val62.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.reportCacheList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReportCacheDocument::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("ReportCacheDocument");

  if (this->__isset.reportCacheList) {
    xfer += oprot->writeFieldBegin("reportCacheList", ::apache::thrift::protocol::T_MAP, 1);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I64, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->reportCacheList.size()));
      std::map<int64_t, ReportCacheItem> ::const_iterator _iter63;
      for (_iter63 = this->reportCacheList.begin(); _iter63 != this->reportCacheList.end(); ++_iter63)
      {
        xfer += oprot->writeI64(_iter63->first);
        xfer += _iter63->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(ReportCacheDocument &a, ReportCacheDocument &b) {
  using ::std::swap;
  swap(a.reportCacheList, b.reportCacheList);
  swap(a.__isset, b.__isset);
}

ReportCacheDocument::ReportCacheDocument(const ReportCacheDocument& other64) {
  reportCacheList = other64.reportCacheList;
  __isset = other64.__isset;
}
ReportCacheDocument& ReportCacheDocument::operator=(const ReportCacheDocument& other65) {
  reportCacheList = other65.reportCacheList;
  __isset = other65.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const ReportCacheDocument& obj) {
  using apache::thrift::to_string;
  out << "ReportCacheDocument(";
  out << "reportCacheList="; (obj.__isset.reportCacheList ? (out << to_string(obj.reportCacheList)) : (out << "<null>"));
  out << ")";
  return out;
}

}} // namespace
