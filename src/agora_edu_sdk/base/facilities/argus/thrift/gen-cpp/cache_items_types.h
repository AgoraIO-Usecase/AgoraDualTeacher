/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef cache_items_TYPES_H
#define cache_items_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace agora { namespace cache {

class DnsItem;

class DnsItem2;

class Policy;

class CacheDocument;

class PolicyDocument;

class ReportCacheItem;

class ReportCacheDocument;

typedef struct _DnsItem__isset {
  _DnsItem__isset() : expired(false), ipList(false) {}
  bool expired :1;
  bool ipList :1;
} _DnsItem__isset;

class DnsItem {
 public:

  static const char* ascii_fingerprint; // = "5DDE96F44B125BEA7379750973DE133C";
  static const uint8_t binary_fingerprint[16]; // = {0x5D,0xDE,0x96,0xF4,0x4B,0x12,0x5B,0xEA,0x73,0x79,0x75,0x09,0x73,0xDE,0x13,0x3C};

  DnsItem(const DnsItem&);
  DnsItem& operator=(const DnsItem&);
  DnsItem() : expired(0) {
  }

  virtual ~DnsItem() throw();
  int64_t expired;
  std::vector<int32_t>  ipList;

  _DnsItem__isset __isset;

  void __set_expired(const int64_t val);

  void __set_ipList(const std::vector<int32_t> & val);

  bool operator == (const DnsItem & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    if (!(ipList == rhs.ipList))
      return false;
    return true;
  }
  bool operator != (const DnsItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DnsItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DnsItem& obj);
};

void swap(DnsItem &a, DnsItem &b);

typedef struct _DnsItem2__isset {
  _DnsItem2__isset() : expired(false), ipList(false) {}
  bool expired :1;
  bool ipList :1;
} _DnsItem2__isset;

class DnsItem2 {
 public:

  static const char* ascii_fingerprint; // = "99F1C039E3B3A6BDFA4977B74CE92EB8";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0xF1,0xC0,0x39,0xE3,0xB3,0xA6,0xBD,0xFA,0x49,0x77,0xB7,0x4C,0xE9,0x2E,0xB8};

  DnsItem2(const DnsItem2&);
  DnsItem2& operator=(const DnsItem2&);
  DnsItem2() : expired(0) {
  }

  virtual ~DnsItem2() throw();
  int64_t expired;
  std::vector<std::string>  ipList;

  _DnsItem2__isset __isset;

  void __set_expired(const int64_t val);

  void __set_ipList(const std::vector<std::string> & val);

  bool operator == (const DnsItem2 & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    if (!(ipList == rhs.ipList))
      return false;
    return true;
  }
  bool operator != (const DnsItem2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DnsItem2 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const DnsItem2& obj);
};

void swap(DnsItem2 &a, DnsItem2 &b);

typedef struct _Policy__isset {
  _Policy__isset() : expired(false), params(false) {}
  bool expired :1;
  bool params :1;
} _Policy__isset;

class Policy {
 public:

  static const char* ascii_fingerprint; // = "B1A3984BF7F74C1706A525A526B7E1B2";
  static const uint8_t binary_fingerprint[16]; // = {0xB1,0xA3,0x98,0x4B,0xF7,0xF7,0x4C,0x17,0x06,0xA5,0x25,0xA5,0x26,0xB7,0xE1,0xB2};

  Policy(const Policy&);
  Policy& operator=(const Policy&);
  Policy() : expired(0), params() {
  }

  virtual ~Policy() throw();
  int64_t expired;
  std::string params;

  _Policy__isset __isset;

  void __set_expired(const int64_t val);

  void __set_params(const std::string& val);

  bool operator == (const Policy & rhs) const
  {
    if (!(expired == rhs.expired))
      return false;
    if (__isset.params != rhs.__isset.params)
      return false;
    else if (__isset.params && !(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const Policy &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Policy & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const Policy& obj);
};

void swap(Policy &a, Policy &b);

typedef struct _CacheDocument__isset {
  _CacheDocument__isset() : dnsList(false), lastSid(false), failedSid(false), policy(false), dnsList2(false), installId(false), netEngine(false), agoraUniqueId(false) {}
  bool dnsList :1;
  bool lastSid :1;
  bool failedSid :1;
  bool policy :1;
  bool dnsList2 :1;
  bool installId :1;
  bool netEngine :1;
  bool agoraUniqueId :1;
} _CacheDocument__isset;

class CacheDocument {
 public:

  static const char* ascii_fingerprint; // = "B94E8EB82640EF5602F0A2815B3544F2";
  static const uint8_t binary_fingerprint[16]; // = {0xB9,0x4E,0x8E,0xB8,0x26,0x40,0xEF,0x56,0x02,0xF0,0xA2,0x81,0x5B,0x35,0x44,0xF2};

  CacheDocument(const CacheDocument&);
  CacheDocument& operator=(const CacheDocument&);
  CacheDocument() : lastSid(), failedSid(), installId(), netEngine(0), agoraUniqueId() {
  }

  virtual ~CacheDocument() throw();
  std::map<std::string, std::map<std::string, DnsItem> >  dnsList;
  std::string lastSid;
  std::string failedSid;
  Policy policy;
  std::map<std::string, std::map<std::string, DnsItem2> >  dnsList2;
  std::string installId;
  int32_t netEngine;
  std::string agoraUniqueId;

  _CacheDocument__isset __isset;

  void __set_dnsList(const std::map<std::string, std::map<std::string, DnsItem> > & val);

  void __set_lastSid(const std::string& val);

  void __set_failedSid(const std::string& val);

  void __set_policy(const Policy& val);

  void __set_dnsList2(const std::map<std::string, std::map<std::string, DnsItem2> > & val);

  void __set_installId(const std::string& val);

  void __set_netEngine(const int32_t val);

  void __set_agoraUniqueId(const std::string& val);

  bool operator == (const CacheDocument & rhs) const
  {
    if (__isset.dnsList != rhs.__isset.dnsList)
      return false;
    else if (__isset.dnsList && !(dnsList == rhs.dnsList))
      return false;
    if (__isset.lastSid != rhs.__isset.lastSid)
      return false;
    else if (__isset.lastSid && !(lastSid == rhs.lastSid))
      return false;
    if (__isset.failedSid != rhs.__isset.failedSid)
      return false;
    else if (__isset.failedSid && !(failedSid == rhs.failedSid))
      return false;
    if (__isset.policy != rhs.__isset.policy)
      return false;
    else if (__isset.policy && !(policy == rhs.policy))
      return false;
    if (__isset.dnsList2 != rhs.__isset.dnsList2)
      return false;
    else if (__isset.dnsList2 && !(dnsList2 == rhs.dnsList2))
      return false;
    if (__isset.installId != rhs.__isset.installId)
      return false;
    else if (__isset.installId && !(installId == rhs.installId))
      return false;
    if (__isset.netEngine != rhs.__isset.netEngine)
      return false;
    else if (__isset.netEngine && !(netEngine == rhs.netEngine))
      return false;
    if (__isset.agoraUniqueId != rhs.__isset.agoraUniqueId)
      return false;
    else if (__isset.agoraUniqueId && !(agoraUniqueId == rhs.agoraUniqueId))
      return false;
    return true;
  }
  bool operator != (const CacheDocument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CacheDocument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const CacheDocument& obj);
};

void swap(CacheDocument &a, CacheDocument &b);

typedef struct _PolicyDocument__isset {
  _PolicyDocument__isset() : version(false), params(false) {}
  bool version :1;
  bool params :1;
} _PolicyDocument__isset;

class PolicyDocument {
 public:

  static const char* ascii_fingerprint; // = "96705E9A3FD7B072319C71653E0DBB90";
  static const uint8_t binary_fingerprint[16]; // = {0x96,0x70,0x5E,0x9A,0x3F,0xD7,0xB0,0x72,0x31,0x9C,0x71,0x65,0x3E,0x0D,0xBB,0x90};

  PolicyDocument(const PolicyDocument&);
  PolicyDocument& operator=(const PolicyDocument&);
  PolicyDocument() : version(0), params() {
  }

  virtual ~PolicyDocument() throw();
  int32_t version;
  std::string params;

  _PolicyDocument__isset __isset;

  void __set_version(const int32_t val);

  void __set_params(const std::string& val);

  bool operator == (const PolicyDocument & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (__isset.params != rhs.__isset.params)
      return false;
    else if (__isset.params && !(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const PolicyDocument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PolicyDocument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const PolicyDocument& obj);
};

void swap(PolicyDocument &a, PolicyDocument &b);

typedef struct _ReportCacheItem__isset {
  _ReportCacheItem__isset() : sent_ts(false), payload(false), level(false), vid(false), cid(false), type(false) {}
  bool sent_ts :1;
  bool payload :1;
  bool level :1;
  bool vid :1;
  bool cid :1;
  bool type :1;
} _ReportCacheItem__isset;

class ReportCacheItem {
 public:

  static const char* ascii_fingerprint; // = "445B302D64924CFE165AEE8082F44C03";
  static const uint8_t binary_fingerprint[16]; // = {0x44,0x5B,0x30,0x2D,0x64,0x92,0x4C,0xFE,0x16,0x5A,0xEE,0x80,0x82,0xF4,0x4C,0x03};

  ReportCacheItem(const ReportCacheItem&);
  ReportCacheItem& operator=(const ReportCacheItem&);
  ReportCacheItem() : sent_ts(0), payload(), level(0), vid(0), cid(0), type(0) {
  }

  virtual ~ReportCacheItem() throw();
  int64_t sent_ts;
  std::string payload;
  int32_t level;
  int32_t vid;
  int32_t cid;
  int32_t type;

  _ReportCacheItem__isset __isset;

  void __set_sent_ts(const int64_t val);

  void __set_payload(const std::string& val);

  void __set_level(const int32_t val);

  void __set_vid(const int32_t val);

  void __set_cid(const int32_t val);

  void __set_type(const int32_t val);

  bool operator == (const ReportCacheItem & rhs) const
  {
    if (!(sent_ts == rhs.sent_ts))
      return false;
    if (!(payload == rhs.payload))
      return false;
    if (!(level == rhs.level))
      return false;
    if (__isset.vid != rhs.__isset.vid)
      return false;
    else if (__isset.vid && !(vid == rhs.vid))
      return false;
    if (__isset.cid != rhs.__isset.cid)
      return false;
    else if (__isset.cid && !(cid == rhs.cid))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const ReportCacheItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReportCacheItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ReportCacheItem& obj);
};

void swap(ReportCacheItem &a, ReportCacheItem &b);

typedef struct _ReportCacheDocument__isset {
  _ReportCacheDocument__isset() : reportCacheList(false) {}
  bool reportCacheList :1;
} _ReportCacheDocument__isset;

class ReportCacheDocument {
 public:

  static const char* ascii_fingerprint; // = "92FC1E5189E49B1A871531354B1011C8";
  static const uint8_t binary_fingerprint[16]; // = {0x92,0xFC,0x1E,0x51,0x89,0xE4,0x9B,0x1A,0x87,0x15,0x31,0x35,0x4B,0x10,0x11,0xC8};

  ReportCacheDocument(const ReportCacheDocument&);
  ReportCacheDocument& operator=(const ReportCacheDocument&);
  ReportCacheDocument() {
  }

  virtual ~ReportCacheDocument() throw();
  std::map<int64_t, ReportCacheItem>  reportCacheList;

  _ReportCacheDocument__isset __isset;

  void __set_reportCacheList(const std::map<int64_t, ReportCacheItem> & val);

  bool operator == (const ReportCacheDocument & rhs) const
  {
    if (__isset.reportCacheList != rhs.__isset.reportCacheList)
      return false;
    else if (__isset.reportCacheList && !(reportCacheList == rhs.reportCacheList))
      return false;
    return true;
  }
  bool operator != (const ReportCacheDocument &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ReportCacheDocument & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const ReportCacheDocument& obj);
};

void swap(ReportCacheDocument &a, ReportCacheDocument &b);

}} // namespace

#endif
