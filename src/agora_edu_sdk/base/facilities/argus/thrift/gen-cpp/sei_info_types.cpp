/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "sei_info_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace agora { namespace rtc { namespace sei {


Canvas::~Canvas() throw() {
}


void Canvas::__set_width(const int32_t val) {
  this->width = val;
}

void Canvas::__set_height(const int32_t val) {
  this->height = val;
}

void Canvas::__set_bgColor(const int32_t val) {
  this->bgColor = val;
__isset.bgColor = true;
}

const char* Canvas::ascii_fingerprint = "E6DDC8C79F3E7066F913E669329FD5DF";
const uint8_t Canvas::binary_fingerprint[16] = {0xE6,0xDD,0xC8,0xC7,0x9F,0x3E,0x70,0x66,0xF9,0x13,0xE6,0x69,0x32,0x9F,0xD5,0xDF};

uint32_t Canvas::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bgColor);
          this->__isset.bgColor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Canvas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Canvas");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bgColor) {
    xfer += oprot->writeFieldBegin("bgColor", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->bgColor);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Canvas &a, Canvas &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.bgColor, b.bgColor);
  swap(a.__isset, b.__isset);
}

Canvas::Canvas(const Canvas& other0) {
  width = other0.width;
  height = other0.height;
  bgColor = other0.bgColor;
  __isset = other0.__isset;
}
Canvas& Canvas::operator=(const Canvas& other1) {
  width = other1.width;
  height = other1.height;
  bgColor = other1.bgColor;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Canvas& obj) {
  using apache::thrift::to_string;
  out << "Canvas(";
  out << "width=" << to_string(obj.width);
  out << ", " << "height=" << to_string(obj.height);
  out << ", " << "bgColor="; (obj.__isset.bgColor ? (out << to_string(obj.bgColor)) : (out << "<null>"));
  out << ")";
  return out;
}


Region::~Region() throw() {
}


void Region::__set_uid(const int32_t val) {
  this->uid = val;
}

void Region::__set_x(const int32_t val) {
  this->x = val;
}

void Region::__set_y(const int32_t val) {
  this->y = val;
}

void Region::__set_width(const int32_t val) {
  this->width = val;
}

void Region::__set_height(const int32_t val) {
  this->height = val;
}

void Region::__set_renderMode(const int32_t val) {
  this->renderMode = val;
}

void Region::__set_zOrder(const int32_t val) {
  this->zOrder = val;
__isset.zOrder = true;
}

void Region::__set_alpha(const int32_t val) {
  this->alpha = val;
__isset.alpha = true;
}

const char* Region::ascii_fingerprint = "09AA06EF16769839BF5183E35F41B7DF";
const uint8_t Region::binary_fingerprint[16] = {0x09,0xAA,0x06,0xEF,0x16,0x76,0x98,0x39,0xBF,0x51,0x83,0xE3,0x5F,0x41,0xB7,0xDF};

uint32_t Region::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->renderMode);
          this->__isset.renderMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->zOrder);
          this->__isset.zOrder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->alpha);
          this->__isset.alpha = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Region::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("Region");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("renderMode", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->renderMode);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.zOrder) {
    xfer += oprot->writeFieldBegin("zOrder", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->zOrder);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alpha) {
    xfer += oprot->writeFieldBegin("alpha", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->alpha);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(Region &a, Region &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.renderMode, b.renderMode);
  swap(a.zOrder, b.zOrder);
  swap(a.alpha, b.alpha);
  swap(a.__isset, b.__isset);
}

Region::Region(const Region& other2) {
  uid = other2.uid;
  x = other2.x;
  y = other2.y;
  width = other2.width;
  height = other2.height;
  renderMode = other2.renderMode;
  zOrder = other2.zOrder;
  alpha = other2.alpha;
  __isset = other2.__isset;
}
Region& Region::operator=(const Region& other3) {
  uid = other3.uid;
  x = other3.x;
  y = other3.y;
  width = other3.width;
  height = other3.height;
  renderMode = other3.renderMode;
  zOrder = other3.zOrder;
  alpha = other3.alpha;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const Region& obj) {
  using apache::thrift::to_string;
  out << "Region(";
  out << "uid=" << to_string(obj.uid);
  out << ", " << "x=" << to_string(obj.x);
  out << ", " << "y=" << to_string(obj.y);
  out << ", " << "width=" << to_string(obj.width);
  out << ", " << "height=" << to_string(obj.height);
  out << ", " << "renderMode=" << to_string(obj.renderMode);
  out << ", " << "zOrder="; (obj.__isset.zOrder ? (out << to_string(obj.zOrder)) : (out << "<null>"));
  out << ", " << "alpha="; (obj.__isset.alpha ? (out << to_string(obj.alpha)) : (out << "<null>"));
  out << ")";
  return out;
}


VideoCompositingLayout::~VideoCompositingLayout() throw() {
}


void VideoCompositingLayout::__set_canvas(const Canvas& val) {
  this->canvas = val;
__isset.canvas = true;
}

void VideoCompositingLayout::__set_regions(const std::vector<Region> & val) {
  this->regions = val;
}

void VideoCompositingLayout::__set_ts(const int64_t val) {
  this->ts = val;
}

void VideoCompositingLayout::__set_appData(const std::string& val) {
  this->appData = val;
__isset.appData = true;
}

const char* VideoCompositingLayout::ascii_fingerprint = "1EAD17DDD77E06D096FB99605D3ADDEC";
const uint8_t VideoCompositingLayout::binary_fingerprint[16] = {0x1E,0xAD,0x17,0xDD,0xD7,0x7E,0x06,0xD0,0x96,0xFB,0x99,0x60,0x5D,0x3A,0xDD,0xEC};

uint32_t VideoCompositingLayout::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->canvas.read(iprot);
          this->__isset.canvas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->regions.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->regions.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += this->regions[_i8].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.regions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->appData);
          this->__isset.appData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VideoCompositingLayout::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("VideoCompositingLayout");

  if (this->__isset.canvas) {
    xfer += oprot->writeFieldBegin("canvas", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->canvas.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("regions", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->regions.size()));
    std::vector<Region> ::const_iterator _iter9;
    for (_iter9 = this->regions.begin(); _iter9 != this->regions.end(); ++_iter9)
    {
      xfer += (*_iter9).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.appData) {
    xfer += oprot->writeFieldBegin("appData", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->appData);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(VideoCompositingLayout &a, VideoCompositingLayout &b) {
  using ::std::swap;
  swap(a.canvas, b.canvas);
  swap(a.regions, b.regions);
  swap(a.ts, b.ts);
  swap(a.appData, b.appData);
  swap(a.__isset, b.__isset);
}

VideoCompositingLayout::VideoCompositingLayout(const VideoCompositingLayout& other10) {
  canvas = other10.canvas;
  regions = other10.regions;
  ts = other10.ts;
  appData = other10.appData;
  __isset = other10.__isset;
}
VideoCompositingLayout& VideoCompositingLayout::operator=(const VideoCompositingLayout& other11) {
  canvas = other11.canvas;
  regions = other11.regions;
  ts = other11.ts;
  appData = other11.appData;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const VideoCompositingLayout& obj) {
  using apache::thrift::to_string;
  out << "VideoCompositingLayout(";
  out << "canvas="; (obj.__isset.canvas ? (out << to_string(obj.canvas)) : (out << "<null>"));
  out << ", " << "regions=" << to_string(obj.regions);
  out << ", " << "ts=" << to_string(obj.ts);
  out << ", " << "appData="; (obj.__isset.appData ? (out << to_string(obj.appData)) : (out << "<null>"));
  out << ")";
  return out;
}

}}} // namespace
